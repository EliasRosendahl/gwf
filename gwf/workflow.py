'''Classes representing a workflow.'''

# FIXME: handle errors

import os, os.path
import time
from dependency_graph import Node, DependencyGraph

def _file_exists(fname):
    return os.path.exists(fname)

def _get_file_timestamp(fname):
    return time.ctime(os.path.getmtime(fname))

class SystemFile:
    '''Class handling files that should be present on the system, i.e.
    files that are not generated by any targets but is specified as an
    input of one or more targets.'''
    
    def __init__(self, filename, wd):
        self.name = filename
        self.dependencies = []
        self.working_dir = wd

    def file_exists(self):
        '''Check if the file exists. It is usually considered a major
        error if it doesn't since no target generates it.'''
        return _file_exists(self.working_dir + '/' + self.name)



class Target:
    '''Class handling targets. Stores the info for executing them.'''
    
    def __init__(self, name, input, output, pbs_options, code, wd):
        self.name = name
        self.input = input
        self.output = output
        self.pbs_options = pbs_options
        self.code = code
        self.working_dir = wd

        # dependencies are the targets that provide files.
        self.dependencies = None # will be filled in by Workflow

        # system_files are expected to be existing, since
        # we don't have targets providing them.
        self.system_files = None # will be filled in by Workflow



    def should_run(self):
        '''Test if this target needs to be run based on whether input
        and output files exist and on their time stamps. Doesn't check
        if upstream targets need to run, only this task; upstream tasks
        are handled by the dependency graph. '''
        
        if len(self.output) == 0:
            return True # If we don't provide output, assume we always
                        # need to run.

        # We need to run if any input or output files are missing
        # Obviously for the output, but for the input we have to assume
        # that we have a dependency that will generate it ...
        # FIXME: probably should have a test for this
               
        for outf in self.output:
            # FIXME: Handle absolute paths...
            if not _file_exists(self.working_dir+'/'+outf):
                return True

        for inf in self.input:
            if not _file_exists(self.working_dir+'/'+inf):
                return True

        # If no file is missing, it comes down to the time stamps. If we
        # only have output and no input, we assume the output is up to
        # date. Touching files and adding input can fix this behaviour
        # from the user side but if we have a program that just creates
        # files we don't want to run it whenever someone needs that
        # output just because we don't have time stamped input.

        if len(self.input) == 0:
            return False

        # if we have both input and output files, check time stamps
        in_timestamp = max(_get_file_timestamp(self.working_dir+'/'+inf)
                           for inf in self.input)
        out_timestamp = max(_get_file_timestamp(self.working_dir+'/'+outf)
                            for outf in self.output)

        return in_timestamp > out_timestamp


    def script_dir(self):
        return self.working_dir+'/.scripts'
    def script_name(self):
        return self.script_dir()+'/'+self.name

    def make_script_dir(self):
        script_dir = self.script_dir()
        if _file_exists(script_dir):
            return
        os.makedirs(script_dir)

    def write_script(self):
        '''Write the code to a script that can be executed.'''

        self.make_script_dir()
        
        f = open('%s/%s' % (self.script_dir(), self.name), 'w')
        
        # Put PBS options at the top
        for options in self.pbs_options:
            print >> f, '#PBS', options
        print >> f
        
        print >> f, '# GWF generated code ...'
        print >> f, 'cd %s' % self.working_dir
        print >> f

        print >> f, '# Script from workflow'
        print >> f, self.code


    def __str__(self):
        sf =''
        dep = ''
        if self.system_files:
            sf = '%s must be present on the file server' % \
                ', '.join(self.system_files)
        if self.dependencies:
            dep = ','.join([('target %s should provide %s ' % (tg.name,of))
                            for of,tg in self.dependencies])
        return '@target %s, input(%s) -> output(%s), %s [%s; %s] %s' % (
            self.name,
            ' '.join(self.input),
            ' '.join(self.output),
            '%d lines of code' % len(self.code.split('\n')),
            sf, dep,
            'Should run' if self.should_run() else "Doesn't need to run"
            )
    __repr__ = __str__ # not really the correct use of __repr__ but easy 
    				   # for printing output when testing...


class Workflow:
    '''Class representing a workflow.'''

    def __init__(self, targets, wd):
        self.targets = targets
        self.working_dir = wd

        # collect the output files so we know who can build them.
        self.providers = dict()
        for target in self.targets.values():
            for output_file in target.output:
                assert output_file not in self.providers
                self.providers[output_file] = target

        # now get dependencies for each target...
        for target in self.targets.values():
            dependencies = []
            for input_file in target.input:
                if input_file in self.providers:
                    dependencies.append((input_file,
                                         self.providers[input_file]))
                else:
                    sysfile = SystemFile(input_file, self.working_dir)
                    dependencies.append((input_file, sysfile))
            target.dependencies = dependencies
        
        # build the dependency graph    
        self.dependency_graph = DependencyGraph(self)




    def get_submission_script(self, target_name):
        '''Generate the script used to submit the tasks.'''
    	
        target = self.targets[target_name]
        schedule, scheduled_tasks = self.dependency_graph.schedule(target.name)
        
        script_commands = []
        for job in schedule:
            # collect the dependencies (in a set since we can have
            # the same task multiple times if it produces more than
            # one output file).

            # make sure we have the scripts for the jobs we want to
            # execute!
            job.target.write_script() # FIXME: this assumes that node is a target ... we don't necessarily know this!

            dependent_tasks = set(node.name
                                  for _,node in job.dependencies
                                  if node.name in scheduled_tasks)
            if len(dependent_tasks) > 0:
                depend = '-W depend=afterok:$%s' % \
                    ':$'.join(dependent_tasks)
            else:
                depend = ''

            script = job.target.script_name()

            command = ' '.join([
                '%s=`' % node.name,
                'qsub -N %s' % node.name,
                depend,
                script,
                '`'])
            script_commands.append(command)

        return '\n'.join(script_commands)


if __name__ == '__main__':
    import sys
    from parser import parse
    workflow = parse(sys.argv[1])
    script = workflow.get_submission_script(sys.argv[2])
    print script
