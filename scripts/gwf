import sys
import argparse
import fnmatch
import os.path
import subprocess

import gwf

from gwf.backends import AVAILABLE_BACKENDS
from gwf.colours import *
from gwf.configurations import read_configurations
from gwf.workflow import build_workflow, dependencies, get_execution_schedule

config = read_configurations()

parser = argparse.ArgumentParser(
    description="""
    Grid WorkFlow -- Keeps track of the status of jobs in a workflow and submits jobs that needs to be run.
    """,
    epilog="""
    For questions, comments or bug-reports contact <mailund@birc.au.dk> or go to https://github.com/mailund/gwf/issues/
    """)

parser.add_argument('-f', '--file',
                    default='workflow.py', dest='workflow_file',
                    help='Workflow file if not the default (workflow.py).')
parser.add_argument('-d', '--dry-run', default=False, action='store_true',
                    help='The submit script will be printed but not executed.')
parser.add_argument('-s', '--status', default=False, action='store_true',
                    help='Print status of targets.')
parser.add_argument('--printspec', default=False, action='store_true',
                    help='Print shell commands for targets.')
parser.add_argument('-k', '--cancel', default=False, action='store_true',
                    help='Cancel queued jobs for targets')
parser.add_argument('-e', '--pattern', default=False, action='store_true',
                    help='Interpret targets names as patterns.')
parser.add_argument('-c', '--clean', default=False, action='store_true',
                    help='Delete output files generated by a target.')
parser.add_argument('--verbose', default=False, action='store_true', help='Verbose output.')

default_backend = config.get('gwf', 'backend')
parser.add_argument('--backend', default=default_backend,
                    choices=AVAILABLE_BACKENDS.keys(),
                    help='''Grid backend to use. If not specified the default ({default}) will be used.
                    '''.format(default=default_backend))

parser.add_argument('targets', nargs='*',
                    help='The targets to process. The default is all targets that are not completed or already running')

args = parser.parse_args()
if not os.path.exists(args.workflow_file):
    parser.error("The specified workflow file '{}' does not exist.\n".format(args.workflow_file))

# Set the backend based on defaults or arguments...
gwf.BACKEND = AVAILABLE_BACKENDS[args.backend]()

execfile(args.workflow_file)

workflow = build_workflow()

if args.clean:
    if len(args.targets) == 0:
        parser.error(
            "No targets specified to clean.\nThis is never a good idea and gwf refuses to clean default targets.\n")

    if args.dry_run:
        for target in args.targets:
            print 'Cleaning', target, 'will delete the following files:'
            print workflow[target].get_existing_outfiles()
            print
    else:
        for target in args.targets:
            workflow[target].clean_target()

    sys.exit(0)

if len(args.targets) > 0:
    all_targets = args.targets
else:
    # take all terminal nodes as default targets
    all_targets = [n.target.name for n in workflow.values() if len(n.dependents) == 0]

if args.pattern:
    defined_targets = [n.target.name for n in workflow.values()]
    all_targets = [fn
                   for pattern in all_targets
                   for fn in fnmatch.filter(defined_targets, pattern)]


def split_tasks(tasks):
    up_to_date, in_queue, to_schedule = [], [], []
    for task in tasks:
        if task.job_in_queue:
            in_queue.append(task)
        elif task.should_run:
            to_schedule.append(task)
        else:
            up_to_date.append(task)
    return up_to_date, in_queue, to_schedule


if args.status:
    all_scheduled = set()
    for target in all_targets:

        tasks = dependencies(workflow, target)
        up_to_date, in_queue, to_schedule = split_tasks(tasks)

        n_up_to_date, n_in_queue, n_to_schedule = len(up_to_date), len(in_queue), len(to_schedule)
        n_total = n_up_to_date + n_in_queue + n_to_schedule
        progress_width = 30
        in_queue_bars = int(float(n_in_queue * progress_width) / n_total)
        to_schedule_bars = int(float(n_to_schedule * progress_width) / n_total)
        up_to_date_bars = progress_width - in_queue_bars - to_schedule_bars

        progress_bar = "{}{}{}".format(COLORS['green'] + '#' * up_to_date_bars,
                                       COLORS['yellow'] + '#' * in_queue_bars,
                                       COLORS['red'] + '#' * to_schedule_bars + CLEAR)
        print '{target} [{status}] ({count_done}/{count_queue}/{count_submit})'.format(
            target=(COLORS['bold'] + target[:24] + CLEAR + '.' * 35)[:35],
            status=progress_bar,
            count_done=COLORS['green'] + '{}'.format(n_up_to_date).rjust(2) + CLEAR,
            count_queue=COLORS['yellow'] + '{}'.format(n_in_queue).rjust(2) + CLEAR,
            count_submit=COLORS['red'] + '{}'.format(n_to_schedule).rjust(2) + CLEAR)

        if args.verbose:
            for task in up_to_date:
                print COLORS['green'], task.target.name, CLEAR
            for task in in_queue:
                print COLORS['yellow'], task.target.name, CLEAR, '({}: {})'.format(task.job_id, task.job_queue_status)
            for task in to_schedule:
                print COLORS['red'], task.target.name, CLEAR
            print

elif args.cancel:
    cancel_command = gwf.BACKEND.build_cancel_command

    for target_name in all_targets:

        job_ids = [task.job_id for task in dependencies(workflow, target_name) if task.job_in_queue]
        if job_ids:
            print '{}Cancelling job computation of target'.format(COLORS['bold']), target_name, '{}'.format(CLEAR)
            command = cancel_command(job_ids)
            try:
                qsub = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
                qsub.stdout.read()
            except OSError, ex:
                print
                print COLORS['red'], COLORS['bold']
                print 'ERROR:', CLEAR,
                print "Couldn't execute the cancellation command {}'{}'{}.".format(COLORS['bold'], ' '.join(command),
                                                                                   CLEAR)
                print ex
                print COLORS['red']
                print "Quiting cancellation", CLEAR
                print

                sys.exit(2)

        workflow[target_name].clean_target()


elif args.printspec:
    # for target_name, job in workflow.targets.items():
    for target_name in all_targets:
        print "{}== {} {}{}".format(COLORS["bold"], target_name, "=" * (60 - 4 - len(target_name)), CLEAR)
        for job in dependencies(workflow, target_name):
            if job.job_in_queue:
                print "-- {}{}:{} ------\n {}".format(COLORS['yellow'], job.target.name, CLEAR, job.target.spec)
            elif job.should_run:
                print "-- {}{}:{} ------\n {}".format(COLORS['red'], job.target.name, CLEAR, job.target.spec)
            else:
                print "-- {}{}:{} ------\n {}".format(COLORS['green'], job.target.name, CLEAR, job.target.spec)
        print "{}{}{}".format(COLORS["bold"], "=" * 60, CLEAR)
        print


else:
    # Executing work flow!
    for target_name in all_targets:
        schedule, scheduled_jobs = get_execution_schedule(workflow, target_name)

        if len(schedule) == 0:
            continue

        print '{}Scheduling computation of target'.format(COLORS['bold']), target_name, '{}...'.format(CLEAR)
        if args.verbose:
            target = workflow[target_name]
            print 'Inputs'
            for name in target.target.options['input']:
                print '   ', os.path.relpath(name)
            print 'Outputs'
            for name in target.target.options['output']:
                print '   ', os.path.relpath(name)
            print

        for job in schedule:

            if job.job_id:
                print "Target", job.target.name, "is already submitted ({})".format(job.job_id)
                continue

            dependents = [dependent for dependent in job.depends_on if dependent.target.name in scheduled_jobs]

            print "Submitting target", job.target.name,
            if len(dependents) > 0 and args.verbose:
                dependents_text = ["{}[{}]".format(dependent.target.name, dependent.job_id) for dependent in dependents]
                print "(depending on {})".format(', '.join(dependents_text)),
            print '...',

            if args.dry_run:
                # For a dry run we just finish here, but write the script so people can check it
                job.write_script()
                print
                continue

            job_id = job.submit(dependents)
            print job_id

        print
